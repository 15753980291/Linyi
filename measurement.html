<!DOCTYPE html>
<html>

<head>
    <title>ä¸´æ²‚æ–‡æ—…-ç©ºé—´é‡ç®—ç³»ç»Ÿ</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://js.arcgis.com/4.24/esri/themes/light/main.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Microsoft YaHei', sans-serif;
        }

        #viewDiv {
            width: 100%;
            height: 100vh;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 999;
        }

        .control-btn {
            padding: 8px 12px;
            margin: 5px;
            background: #1890ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .result-panel {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            text-align: center;
        }

        #instruction {
            margin-top: 10px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 4px;
            font-size: 13px;
        }
    </style>
    
</head>

<body>
    <div class="control-panel">
        <h3 style="margin-top:0;color:#1890ff">ç©ºé—´é‡ç®—å·¥å…·</h3>
        <button id="distanceBtn" class="control-btn">ğŸ“ è·ç¦»é‡ç®—</button>
        <button id="areaBtn" class="control-btn">ğŸ“ é¢ç§¯é‡ç®—</button>
        <button id="clearBtn" class="control-btn">ğŸ—‘ï¸ æ¸…é™¤</button>
        <div id="instruction">è¯·é€‰æ‹©æµ‹é‡ç±»å‹å¼€å§‹æ“ä½œ</div>
    </div>

    <div id="viewDiv"></div>
    <div class="result-panel" id="resultPanel">
        <span style="color:#1890ff">ä¸´æ²‚æ–‡æ—…å¯¼èˆªç³»ç»Ÿ</span> | æµ‹é‡ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ
    </div>

    <script src="https://js.arcgis.com/4.24/"></script>
    <script>
        require([
            "esri/Map",
            "esri/views/MapView",
            "esri/layers/FeatureLayer",
            "esri/layers/GraphicsLayer",
            "esri/Graphic",
            "esri/geometry/Polyline",
            "esri/geometry/Polygon",
            "esri/geometry/support/webMercatorUtils",
            "esri/config"
        ], function (
            Map, MapView, FeatureLayer,
            GraphicsLayer, Graphic,
            Polyline, Polygon,
            webMercatorUtils, esriConfig
        ) {
            // åˆå§‹åŒ–åœ°å›¾
            const map = new Map({
                basemap: "streets"
            });

            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [118.35646, 35.10333], // ä¸´æ²‚ä¸­å¿ƒåæ ‡
                zoom: 12
            });

            // è®¾ç½®ä»£ç†ï¼ˆå¦‚éœ€ï¼‰
            // esriConfig.request.proxyUrl = "/proxy/";

            // åŠ è½½GeoSceneæ™¯ç‚¹å›¾å±‚
            const attractionsLayer = new FeatureLayer({
                url: "https://www.geosceneonline.cn/server/rest/services/Hosted/ä¸´æ²‚/FeatureServer/0",
                outFields: ["*"],
                popupTemplate: {
                    title: "{name}",
                    content: "æ™¯åŒºç‰¹è‰²ï¼š{feature}<br>æ™¯åŒºçº§åˆ«ï¼š{Grade}"
                }
            });
            map.add(attractionsLayer);

            // é‡æµ‹åŠŸèƒ½å®ç°
            const graphicsLayer = new GraphicsLayer();
            map.add(graphicsLayer);

            let measureMode = null;
            let measurePoints = [];
            let measureGraphic = null;

            // è·ç¦»é‡ç®—
            document.getElementById("distanceBtn").addEventListener("click", function () {
                resetMeasurement();
                measureMode = "distance";
                updateInstruction("ç‚¹å‡»åœ°å›¾é€‰æ‹©èµ·ç‚¹ï¼Œå†æ¬¡ç‚¹å‡»é€‰æ‹©ç»ˆç‚¹");
            });

            // é¢ç§¯é‡ç®—
            document.getElementById("areaBtn").addEventListener("click", function () {
                resetMeasurement();
                measureMode = "area";
                updateInstruction("ç‚¹å‡»æ·»åŠ é¡¶ç‚¹ï¼ŒåŒå‡»å®Œæˆç»˜åˆ¶");
            });

            // æ¸…é™¤
            document.getElementById("clearBtn").addEventListener("click", resetMeasurement);

            // åœ°å›¾ç‚¹å‡»äº‹ä»¶
            view.on("click", function (evt) {
                if (!measureMode) return;

                const point = webMercatorUtils.xyToLngLat(evt.mapPoint.x, evt.mapPoint.y);
                measurePoints.push(point);

                if (measureMode === "distance" && measurePoints.length === 2) {
                    completeDistanceMeasurement();
                } else if (measureMode === "area") {
                    updateAreaMeasurement();
                }
            });

            // åœ°å›¾åŒå‡»äº‹ä»¶ï¼ˆé¢ç§¯æµ‹é‡å®Œæˆï¼‰
            view.on("double-click", function () {
                if (measureMode === "area" && measurePoints.length >= 3) {
                    completeAreaMeasurement();
                }
            });

            // æ™¯ç‚¹ç‚¹å‡»äº‹ä»¶ï¼ˆæ”¯æŒç›´æ¥ç‚¹å‡»æ™¯ç‚¹æµ‹é‡ï¼‰
            view.popup.on("trigger-action", function (event) {
                if (event.action.id === "measure-from-here" && measureMode === "distance") {
                    const feature = view.popup.selectedFeature;
                    const point = [
                        feature.geometry.longitude,
                        feature.geometry.latitude
                    ];

                    measurePoints.push(point);
                    if (measurePoints.length === 1) {
                        updateInstruction("å·²é€‰æ‹©èµ·ç‚¹ï¼Œè¯·é€‰æ‹©ç»ˆç‚¹");
                    } else if (measurePoints.length === 2) {
                        completeDistanceMeasurement();
                    }
                }
            });

            // æ›´æ–°è·ç¦»æµ‹é‡
            function updateDistanceMeasurement() {
                graphicsLayer.remove(measureGraphic);

                if (measurePoints.length > 1) {
                    const polyline = new Polyline({
                        paths: [measurePoints],
                        spatialReference: { wkid: 4326 }
                    });

                    measureGraphic = new Graphic({
                        geometry: polyline,
                        symbol: {
                            type: "simple-line",
                            color: [56, 168, 0, 0.8],
                            width: 3
                        }
                    });
                    graphicsLayer.add(measureGraphic);

                    const distance = calculateDistance(measurePoints[0], measurePoints[1]);
                    updateResult(`è·ç¦»ï¼š${distance.toFixed(2)} ç±³`);
                }
            }

            // å®Œæˆè·ç¦»æµ‹é‡
            function completeDistanceMeasurement() {
                updateDistanceMeasurement();
                updateInstruction("è·ç¦»æµ‹é‡å®Œæˆ");
                measureMode = null;
            }

            // æ›´æ–°é¢ç§¯æµ‹é‡
            function updateAreaMeasurement() {
                graphicsLayer.remove(measureGraphic);

                if (measurePoints.length >= 3) {
                    const polygon = new Polygon({
                        rings: [measurePoints.concat([measurePoints[0]])], // é—­åˆå¤šè¾¹å½¢
                        spatialReference: { wkid: 4326 }
                    });

                    measureGraphic = new Graphic({
                        geometry: polygon,
                        symbol: {
                            type: "simple-fill",
                            color: [56, 168, 0, 0.3],
                            outline: {
                                color: [56, 168, 0, 0.8],
                                width: 2
                            }
                        }
                    });
                    graphicsLayer.add(measureGraphic);

                    const area = calculateArea(measurePoints);
                    updateResult(`é¢ç§¯ï¼š${area.toFixed(2)} å¹³æ–¹ç±³ (${(area / 666.67).toFixed(2)} äº©)`);
                }
            }

            // å®Œæˆé¢ç§¯æµ‹é‡
            function completeAreaMeasurement() {
                updateAreaMeasurement();
                updateInstruction("é¢ç§¯æµ‹é‡å®Œæˆ");
                measureMode = null;
            }

            // è®¡ç®—è·ç¦»ï¼ˆç±³ï¼‰
            function calculateDistance(point1, point2) {
                const R = 6371000; // åœ°çƒåŠå¾„
                const dLat = (point2[1] - point1[1]) * Math.PI / 180;
                const dLon = (point2[0] - point1[0]) * Math.PI / 180;
                const a =
                    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(point1[1] * Math.PI / 180) *
                    Math.cos(point2[1] * Math.PI / 180) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
                return R * c;
            }

            // è®¡ç®—é¢ç§¯ï¼ˆå¹³æ–¹ç±³ï¼‰
            function calculateArea(points) {
                let area = 0;
                const n = points.length;
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += points[i][0] * points[j][1];
                    area -= points[j][0] * points[i][1];
                }
                return Math.abs(area) * 111319.488 * 111319.488 / 2; // ç»çº¬åº¦è½¬å¹³é¢è¿‘ä¼¼
            }

            // æ›´æ–°æ“ä½œæç¤º
            function updateInstruction(text) {
                document.getElementById("instruction").innerHTML =
                    `<span style="color:#1890ff">æ“ä½œæç¤ºï¼š</span>${text}`;
            }

            // æ›´æ–°ç»“æœå±•ç¤º
            function updateResult(text) {
                document.getElementById("resultPanel").innerHTML = `
                    <span style="color:#1890ff">ğŸ“ æµ‹é‡ç»“æœ</span><br>
                    ${text}
                `;
            }

            // é‡ç½®æµ‹é‡
            function resetMeasurement() {
                measureMode = null;
                measurePoints = [];
                graphicsLayer.removeAll();
                updateResult("è¯·é€‰æ‹©æµ‹é‡å·¥å…·å¼€å§‹æµ‹é‡");
                updateInstruction("è¯·é€‰æ‹©æµ‹é‡ç±»å‹");
            }

            // åˆå§‹åŒ–å¼¹çª—åŠ¨ä½œï¼ˆç”¨äºæ™¯ç‚¹ç›´æ¥æµ‹é‡ï¼‰
            attractionsLayer.popupTemplate.actions = [{
                title: "ä»æ­¤ç‚¹å¼€å§‹æµ‹é‡",
                id: "measure-from-here",
                className: "esri-icon-measure-line"
            }];
        });
    </script>
</body>

</html>